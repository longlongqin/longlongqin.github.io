<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>C&amp;C++/LearnCpp-chapter6 - 龙龙‘S BLOG</title><meta name="keywords" content="C/C++"><meta name="description" content="LearnCpp chapter6https://www.learncpp.com"><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/archives/2faa8a4b.html">C&C++/LearnCpp-chapter6</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://www.longlongqin.top" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongqin</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>学习笔记&nbsp;/&nbsp;C/C++</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年4月6日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：15.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：63分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><center><p center large><red>LearnCpp chapter6</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="6-2-用户自定义namespace"><a href="#6-2-用户自定义namespace" class="headerlink" title="6.2 用户自定义namespace"></a>6.2 用户自定义namespace</h2><p>在<a href="https://www.learncpp.com/cpp-tutorial/2-9-naming-collisions-and-an-introduction-to-namespaces/" target="_blank" rel="noopener">2.9 – Naming collisions and an introduction to namespaces</a>中讲解了命名冲突和命名空间的内容。现在再次看一下<strong>命名冲突</strong>。</p><blockquote><p>下面的<code>foo.cpp</code>和<code>goo.cpp</code>两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：</p></blockquote><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() adds the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(intx, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() subtracts the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//forward declaration for dosomething</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dosometing(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosometing will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译器会将<code>foo.cpp</code>和<code>goo.cpp</code>都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：</p><p><code>goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here</code></p><hr><p>一个较好的解决办法就是，将你的函数放在你自己定义的“<em><em>命名空间</em>namespace</em> **”中。</p><hr><ul><li><p><strong>定义自己的namespace</strong></p><p>C++允许我们使用关键字<em>namespace</em>来定义自己的命名空间。由用户自定义的命名空间，叫：<strong>user-defined namespaces</strong>。而 由C++提供的命名空间，如 <code>global namespace</code>；或者由库提供的，如<code>namespace std</code>；它们就不是user-defined namespaces。</p><blockquote><p><strong>命名空间的标识符</strong>通常 <strong>不大写</strong>。</p></blockquote><p>下面是对上面命名冲突的函数的改写：</p><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo <span class="comment">//定义一个命名空间，名字为：foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> goo  <span class="comment">//定义一个命名空间，名字为：goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//提前对函数dosomething()进行声明</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;dosomething(<span class="number">4</span>, <span class="number">3</span>)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosomething will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个两个<code>dosomething()</code>函数都分别属于不同的命名空间了。让我们来运行一下。</p><p>😂，新问题又出现了：</p><blockquote><p><code>ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main</code></p></blockquote><p>在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在<em>global namespace</em>中的<code>dosomething</code>的定义。</p><blockquote><p>这是因为我们虽然为两个<code>dosomething</code>分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。</p></blockquote><hr><p><strong>这里有两个解决方案：1.使用<em>scope resolution operator<em>；2.通过</em>using statements</em></strong></p><hr></li><li><p>*<em>使用范围解析操作符(::)访问名称空间 *</em></p><blockquote><p>【<strong>范围解析操作符：<em>scope resolution operator(::)</em></strong>】</p></blockquote><p>告诉编译器在特定名称空间中查找标识符的最佳方法是使用<em>scope resolution operator(::)</em></p><blockquote><p>“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)</p></blockquote><p>下面是一个例子：</p><p><em>对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo <span class="comment">// define a namespace named foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> goo <span class="comment">// define a namespace named goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::doSomething(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the doSomething() that exists in namespace foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到main函数中的这个语句：<code>std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\n&#39;;</code>，就是用了“范围解析符 :: ”。</p><p>该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。</p><p><strong>所以，<code>foo::dosomething(4,3)</code>，就表示：调用的函数<code>dosomething()</code>是来源于命名空间foo中的。</strong></p></blockquote></li></ul><hr><center><p center large>小结</p></center><p>解决命名冲突的步骤为：</p><ol><li>为这些同名的函数，均设置自己的命名空间；</li><li>在使用这个同名函数的时候，还需要加上“范围解析符 :: ”</li></ol><hr><ul><li><p><strong>没有前缀的范围解析符</strong></p><blockquote><p><strong>格式：<code>:: 标识符</code></strong></p><p><strong>没有前缀的范围解析符，<u>就相当于它的范围是全局命名空间</u></strong>。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//this print lives in the global namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"there"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// this print lives in the foo namespace</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	foo::<span class="built_in">print</span>(); <span class="comment">// call foo::print()</span></span><br><span class="line">	::<span class="built_in">print</span>(); <span class="comment">// call print() in global namespace (same as just calling print() in this case)</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>允许多个命名空间块：Multiple namespace blocks allowed</strong></p><blockquote><p>在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。<strong><u>命名空间内的所有声明都被认为是命名空间的一部分</u>。</strong></p></blockquote><hr></li></ul><p>例子1（多文件中）：</p><p><code>circle.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CIRCLE_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi&#123; <span class="number">3.14</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>growth.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(GROWTH_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROWTH_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the constant e is also part of namespace basicMath</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> e&#123; <span class="number">2.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span> <span class="comment">// for basicMath::pi</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"growth.h"</span> <span class="comment">// for basicMath::e</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::e &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>3.14</p><p>2.7</p><blockquote><p>标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!</p></blockquote><p><em>【note】：尽管你可以利用这个功能，将你写的函数添加到<code>std namespace</code>中，但是<code>std namespace</code>有一个规则，那就是禁止用户将自己的函数扩展到它的里面。</em></p><hr><ul><li><p>例子2</p><p>如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。</p><p><code>add.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(ADD_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// function add() is part of namespace basicMath</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define the function add()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// for basicMath::add()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::add(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如果在<code>add.cpp</code>中省略了<em>namespace</em>，将会导致链接器找不到<code>basicMath::add</code>。</p><p><em>因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。</em></p></li><li><p>如果在<code>add.h</code>中省略<em>namespace</em>，将会导致在“main.cpp”中不能使用<code>basicMath::add</code></p><p><em>因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。</em></p></li></ol></blockquote></li></ul><hr><ul><li><p><strong>嵌套命名空间</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> goo <span class="comment">// goo is a namespace inside the foo namespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，当我们要调用函数<code>add</code>的时候，<strong>我们使用格式为：<code>foo::goo::add</code></strong></p></blockquote><hr><p>在C++17中，嵌套的命名空间也可以这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo::goo <span class="comment">// goo is a namespace inside the foo namespace (C++17 style)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>给命名空间设置别名：namespace aliases</strong></p><p>在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">namespace</span> goo</span><br><span class="line">	&#123;</span><br><span class="line">	        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        	</span>&#123;</span><br><span class="line">	            <span class="keyword">return</span> x + y;</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> boo = foo::goo; <span class="comment">// boo now refers to foo::goo</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boo::add() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is really foo::goo::add()</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The boo alias ends here</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="6-3-局部变量"><a href="#6-3-局部变量" class="headerlink" title="6.3 局部变量"></a>6.3 局部变量</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>,介绍了局部变量，它是在函数中的形参。</p><h3 id="局部变量的块范围"><a href="#局部变量的块范围" class="headerlink" title="局部变量的块范围"></a>局部变量的块范围</h3><p>标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。</p><blockquote><p>局部变量的 <strong>块范围(block scope)</strong>，中的范围就是：从他们定义开始，到这个块结束 的这个范围。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i enters scope here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">// d enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// i and d go out of scope here</span></span><br></pre></td></tr></table></figure><p>虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//x and y enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将x、y中较大者分配给max</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>&#123;(x&gt;y) ? x : y&#125;; <span class="comment">//max enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;<span class="comment">// x, y and max leave scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="同一范围内的变量名不相同"><a href="#同一范围内的变量名不相同" class="headerlink" title="同一范围内的变量名不相同"></a>同一范围内的变量名不相同</h3><p>下面的函数在编译时会出错，因为该范围内的变量名相同了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;&#125;; <span class="comment">//编译时会出错，因为这里的x和形参x之间命名冲突了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="局部变量的自动存储期"><a href="#局部变量的自动存储期" class="headerlink" title="局部变量的自动存储期"></a>局部变量的自动存储期</h3><blockquote><p>变量的<strong>存储期(storage duration),也叫持续时长(duration)</strong>决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的<strong>“生命周期(lifetime)”</strong></p></blockquote><p>例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i created and initialized here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">//d created and initialized here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// i and d are destoryed here</span></span><br></pre></td></tr></table></figure><p>由于这个原因，局部变量 有时也被称为：<strong>自动变量</strong></p><hr><h3 id="嵌套快中的局部变量"><a href="#嵌套快中的局部变量" class="headerlink" title="嵌套快中的局部变量"></a>嵌套快中的局部变量</h3><p>局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//外部块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//x enters scope and is created here</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套块</span></span><br><span class="line">        <span class="keyword">int</span> y &#123;<span class="number">7</span>&#125;; <span class="comment">//y enters scope and is created here</span></span><br><span class="line">    &#125; <span class="comment">// y goes out of scope and is destroyed here</span></span><br><span class="line">    <span class="comment">//此时，y就不能再被用了，因为它不属于现在所在的范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope and is destoryed here</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的</strong>，即也可以访问它。</p></blockquote><hr><h3 id="局部变量的无连接"><a href="#局部变量的无连接" class="headerlink" title="局部变量的无连接"></a>局部变量的无连接</h3><p>标识符的另一个属性就是：<strong>“连接(linkage)”</strong>。一个标识符的<em>linkage</em>决定了该标识符的其他声明是否引用的是相同的对象。</p><blockquote><p><strong>局部变量没有<em>关联性</em>，也就是说对一个标识符的每一个声明都代表不同的对象</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">2</span>&#125;; <span class="comment">// local variable, no linkage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x &#123;<span class="number">3</span>&#125;; <span class="comment">//这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同)</span></span><br><span class="line">        <span class="comment">//但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量定义的范围"><a href="#变量定义的范围" class="headerlink" title="变量定义的范围"></a>变量定义的范围</h3><p>如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//don't define y here</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//y只在这个块中被使用，所以在这里定义它</span></span><br><span class="line">        <span class="keyword">int</span> y&#123;<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>所以，我们尽量把变量定义在，使用它的范围内部</strong>。</p></blockquote><hr><h2 id="6-4-全局变量"><a href="#6-4-全局变量" class="headerlink" title="6.4 全局变量"></a>6.4 全局变量</h2><h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><p>通常，全局变量声明是在：<strong>头文件的下面，在其他代码的上面</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数外面声明的变量是全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;; <span class="comment">// global variable g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_x goes out of scope here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*****/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量</p></blockquote><hr><h3 id="全局变量的file-scope-amp-静态持续时间"><a href="#全局变量的file-scope-amp-静态持续时间" class="headerlink" title="全局变量的file scope&amp;静态持续时间"></a>全局变量的file scope&amp;静态持续时间</h3><blockquote><p>file scope也叫：<strong>全局范围(global scope)</strong>或者<strong>全局命名空间范围(global namespace scope)</strong></p><blockquote><p>因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有<em>global namespace scope</em>这个叫法。</p></blockquote></blockquote><p>也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。</p><hr><p>全局变量在程序开始被创建，在程序结束时被销毁。这成为“<strong>静态持续时间(static duration)</strong>”</p><blockquote><p>有着‘static duration’的变量，也被称为：“<strong>静态变量(static variable)</strong>”</p></blockquote><hr><p><u><strong>局部变量默认是不被初始化的，全局变量默认是被初始化为0的</strong></u></p><ul><li><p><strong>全局变量的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//没有显示的初始化变量(所以默认初始化为0)</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123;&#125;; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="keyword">int</span> g_z&#123;<span class="number">3</span>&#125;; <span class="comment">//显示的初始化为3</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="常量局部变量"><a href="#常量局部变量" class="headerlink" title="常量局部变量"></a>常量局部变量</h3><p>与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_x; <span class="comment">//error:常量型的变量必须要被初始化</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_w; <span class="comment">//error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_y and g_z goes out of scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-constant global variables(非常量的全局变量)</span></span><br><span class="line"><span class="keyword">int</span> g_x;                 <span class="comment">// defines non-initialized global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;;              <span class="comment">// defines explicitly zero-initialized global variable</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123; <span class="number">1</span> &#125;;           <span class="comment">// defines explicitly initialized global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Const global variables</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y;           <span class="comment">// error: const variables must be initialized</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized global constant</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Constexpr global variables</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;       <span class="comment">// error: constexpr variables must be initialized</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized global const</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-5-变量被隐藏"><a href="#6-5-变量被隐藏" class="headerlink" title="6.5 变量被隐藏"></a>6.5 变量被隐藏</h2><h3 id="局部变量被隐藏"><a href="#局部变量被隐藏" class="headerlink" title="局部变量被隐藏"></a>局部变量被隐藏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// outer block</span></span><br><span class="line">	<span class="keyword">int</span> apples &#123; <span class="number">5</span> &#125;; <span class="comment">// 嵌套外部的apples</span></span><br><span class="line">    </span><br><span class="line">    &#123;<span class="comment">// nested block</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这里的apples是嵌套外部的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> apples &#123;<span class="number">0</span>&#125;; <span class="comment">//在嵌套内部定义变量apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了</span></span><br><span class="line">        apples = <span class="number">10</span>; <span class="comment">//现在被赋值的apples指的是嵌套内部的apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; apples &lt;&lt;<span class="string">'\n'</span>'</span><br><span class="line">    &#125; <span class="comment">//嵌套块内部的apples被销毁</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125; <span class="comment">//嵌套外部的apples被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量被隐藏"><a href="#全局变量被隐藏" class="headerlink" title="全局变量被隐藏"></a>全局变量被隐藏</h3><p>就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。<strong>局部变量可以将全局中的同名变量隐藏起来:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"global variable a："</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，全局变量a就被这里的局部变量a 隐藏起来了</span></span><br><span class="line">    </span><br><span class="line">    ++a; <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 局部变量a被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 5</span><br></pre></td></tr></table></figure><hr><p>然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 <em>范围解析符(::)</em>（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，将全局变量a隐藏起来了</span></span><br><span class="line">    ++a； <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">        </span><br><span class="line">    --(::a); <span class="comment">//此时是对于全局变量，减一</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global variable a: "</span> &lt;&lt; ::a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;<span class="comment">//local a 被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 4</span><br></pre></td></tr></table></figure><hr><h3 id="避免变量被隐藏"><a href="#避免变量被隐藏" class="headerlink" title="避免变量被隐藏"></a>避免变量被隐藏</h3><p>通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。</p><hr><h2 id="6-6-内部连接"><a href="#6-6-内部连接" class="headerlink" title="6.6 内部连接"></a>6.6 内部连接</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/local-variables/" target="_blank" rel="noopener">6.3 – Local variables</a>中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”</p><p>全局变量和函数标识符有：<strong>内部链接(internal linkage)</strong>和<strong>外部链接(external linkage)</strong>。本节主要讲内部链接。</p><hr><p>一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【<strong>也就是说，它没有暴露给链接器</strong>】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。</p><hr><h3 id="全局变量内部连接"><a href="#全局变量内部连接" class="headerlink" title="全局变量内部连接"></a>全局变量内部连接</h3><p>全局变量是内部链接时，也被称为：<strong>内部变量(<em>internal variables</em>)</strong>。</p><blockquote><p>让 非常量的全局变量 成为内部变量，需要使用<strong>关键字<code>static</code></strong>；（因为非常量的全局变量默认是 外部链接 的）</p><p>而 常量的全局变量 <strong>默认</strong>的就是 内部变量。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x; <span class="comment">//非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//const 的全局变量默认是 内部连接</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//constexpr 的全局变量默认是 内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>和<code>constexpr</code>的全局变量默认是 内部连接(所以，不需要加 关键字<code>static</code>)</p></blockquote><hr><h3 id="一个定义规则和内部连接"><a href="#一个定义规则和内部连接" class="headerlink" title="一个定义规则和内部连接"></a>一个定义规则和内部连接</h3><p>还记得在 <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/" target="_blank" rel="noopener">2.7 – Forward declarations and definitions</a>,中讲到一个定义的规则：<em>在文件或程序中，*</em>一个*<em>对象或者函数只能有一个定义</em>。</p><p>然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？</p><blockquote><p>答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。</p></blockquote><hr><h3 id="函数内部连接"><a href="#函数内部连接" class="headerlink" title="函数内部连接"></a>函数内部连接</h3><p>因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。</p><p>如：</p><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数前使用关键字static，表示它现在只在这个文件中有效</span></span><br><span class="line"><span class="comment">//如果，企图通过函数提前声明从，从另一个文件访问它，将失败</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//对函数add，提前声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，在链接器连接时，将会出错。因为函数add在<code>main.cpp</code>中不可访问</p><hr><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal global variables definitions:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x;          <span class="comment">// defines non-initialized internal global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized internal global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized internal global const variable</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized internal global constexpr variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Internal function definitions:</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;;     <span class="comment">// defines internal function</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-7-外部连接"><a href="#6-7-外部连接" class="headerlink" title="6.7 外部连接"></a>6.7 外部连接</h2><p>一个标识符具有 <strong>外部连接(external linkage)</strong>的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过<em>提前声明</em>来访问它）</p><blockquote><p>所以，具有外部连接属性的表示符，才是真正的“全局”变量</p></blockquote><hr><h3 id="函数默认是外部链接"><a href="#函数默认是外部链接" class="headerlink" title="函数默认是外部链接"></a>函数默认是外部链接</h3><p>在 <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/" target="_blank" rel="noopener">2.8 – Programs with multiple code files</a>中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。</p><p>在从其他文件中调用函数时，我们必须要对这个函数进行 <strong>提前声明(forward declaration)</strong></p><blockquote><p>因为，<strong>提前声明</strong>可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义</p></blockquote><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> <span class="comment">//这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>; <span class="comment">//对函数进行提前声明，使得该函数在这个文件中可以被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sayHi(); <span class="comment">//这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量外部连接"><a href="#全局变量外部连接" class="headerlink" title="全局变量外部连接"></a>全局变量外部连接</h3><p>全局变量具有外部连接属性时，也称为：<strong>外部变量(external variables)</strong></p><blockquote><p>非常量的全局变量默认是 外部变量；</p><p>常量的全局变量 要想成为外部变量，需要使用<strong>关键字<code>extern</code></strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部变量；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;;<span class="comment">//const 的全局变量可以被定义成 外部变量，需要加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">3</span>&#125;; <span class="comment">//constexpr 的全局变量可以被定义成 外部变量,需要加关键字extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。</p></blockquote><hr><h3 id="extern提前声明变量"><a href="#extern提前声明变量" class="headerlink" title="extern提前声明变量"></a><code>extern</code>提前声明变量</h3><p>要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行<em>提前声明</em>。对于变量，在创建一个<strong>提前声明时，也是需要使用关键字<code>extern</code>的(</strong>没有初始化值)：</p><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量的定义</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;; <span class="comment">//常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。它的定义在其他文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//对常量变量g_y的提前声明。它的定义在其他文件中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>&lt;&lt; g_x; <span class="comment">//结果为2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数提前声明不用extern"><a href="#函数提前声明不用extern" class="headerlink" title="函数提前声明不用extern"></a>函数提前声明不用<code>extern</code></h3><p><strong>函数的提前声明不需要关键字<code>extern</code></strong></p><blockquote><p>编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。</p></blockquote><p><strong>变量的提前声明必须要用关键字<code>extern</code></strong>，</p><blockquote><p>来帮助区分 <strong>变量定义</strong> 和 <strong>变量提前声明</strong>(它们看起来是一样的):</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常量</span></span><br><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//变量的定义(如果需要，可进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//变量的提前声明(提前声明  不带初始化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;;<span class="comment">//定义变量(常量的定义必须要进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//提前声明(提前声明  不带初始化)</span></span><br></pre></td></tr></table></figure><hr><h3 id="file范围VS-global范围"><a href="#file范围VS-global范围" class="headerlink" title="file范围VS.global范围"></a>file范围VS.global范围</h3><p>看下面的例子：</p><p><code>global.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//（非常量的变量）默认是外部连接</span></span><br><span class="line"><span class="comment">//g_x goes out scope here</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。可以在此文件中使用g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x; <span class="comment">//应该输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g_x的提前声明 goes out of scope here</span></span><br></pre></td></tr></table></figure><blockquote><p>变量g_x的<strong>文件范围(file scope)</strong>是在<code>global.cpp</code>中。它在该文件中定义之后，就可以被使用。</p><p>但是它<strong>不能<u>直接</u>在其他文件中使用</strong>。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字<code>extern</code>)</p></blockquote><hr><p>也就是说，“文件范围”通常用于具有<em>内部连接</em>属性的全局变量；“全局范围”更多用于具有<em>外部连接</em>属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)</p><hr><h3 id="全局变量初始化顺序问题"><a href="#全局变量初始化顺序问题" class="headerlink" title="全局变量初始化顺序问题"></a>全局变量初始化顺序问题</h3><p>全局变量的初始化是程序启动的一部分，在执行<code>mian</code>函数之前，这个过程分为两部分：</p><ul><li><p>第一部分，称为 <strong><em>static initialization</em>静态初始化</strong>。</p><blockquote><p>在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；</p><blockquote><p>eg,</p><p><code>const a {1};</code>那么a就被初始化为1</p><p><code>constexpr a{1};</code>那么a就被初始化为1</p></blockquote><p>定义时没有给定初始值的全局变量<strong>(也使常量的全局变量，但没有显示初始化为0)</strong>被默认初始化为0。</p><blockquote><p><code>const a {};</code>那么a就默认被初始化为0</p><p><code>constexpr a{};</code>那么a就默认被初始化为0</p></blockquote></blockquote></li><li><p>第二部分，称为 <strong><em>dynamic initialization</em>动态初始化</strong>。</p><blockquote><p>这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。</p></blockquote></li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_something &#123;init()&#125;; <span class="comment">//非常量的变量初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>在单位件的程序中，全局变量按照定义的顺序被初始化</p></blockquote><p>这个规则有几个例外。考虑到这一点，<strong>您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_x&#123; initx() &#125;; <span class="comment">// g_x is initialized first</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123; inity() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_y; <span class="comment">// g_y isn't initialized when this is called</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">' '</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*******/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>再多文件程序中，<strong>不同文件之间的初始化顺序是没有规定的</strong>。</p><blockquote><p>例如，有两个文件<code>a.cpp</code>和<code>b.cpp</code>，它们两个文件谁先被初始化是不确定的。</p></blockquote><p>所以，如果在<code>a.cpp</code>中有一个变量的值是依赖于<code>b.cpp</code>。那么就有50%的可能这些变量还没有被初始化。</p><hr><p>注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。</p><hr><p>小结：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// External global variable definitions:</span></span><br><span class="line"><span class="keyword">int</span> g_x;                       <span class="comment">// defines non-initialized external global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized const external global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_x&#123; <span class="number">2</span> &#125;; <span class="comment">// defines initialized constexpr external global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward declarations</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_y;                <span class="comment">// forward declaration for non-constant global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y;          <span class="comment">// forward declaration for const global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;      <span class="comment">// not allowed: constexpr variables can't be forward declared</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-8-全局常量-amp-内联变量"><a href="#6-8-全局常量-amp-内联变量" class="headerlink" title="6.8 全局常量&amp;内联变量"></a>6.8 全局常量&amp;内联变量</h2><blockquote><p><strong>Global constants and inline variables</strong></p></blockquote><p>一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。</p><h3 id="全局常量作为内部变量"><a href="#全局常量作为内部变量" class="headerlink" title="全局常量作为内部变量"></a>全局常量作为内部变量</h3><p>在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:</p><ol><li><p>首先，创建一个头文件来存放这些常量；</p></li><li><p>在这个头文件中，定义一个命名空间（在 <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces/" target="_blank" rel="noopener">6.2 – User-defined namespaces</a>讲解过命名空间）；</p></li><li><p>然后，将常量加入这个命名空间中（请确保它们的类型是<code>constexpr</code>）；</p></li><li><p>在你要用这些变量的文件中，加上这个头文件<code>#include &quot;xxx&quot;</code></p></li></ol><hr><p>eg:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义你自己的命名空间(用来存储常量)</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，常量有 内部连接</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//....常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">//：在这个文件中包含每个常量的副本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;; <span class="comment">//radius：半径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt;radius;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the circumference is: "</span> &lt;&lt;<span class="number">2</span>* radius* constants::pi;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在<code>main.cpp</code>文件中，要想访问<code>constants</code>中的常量，我们需要使用 <strong>范围解析符(::)</strong>。</p><p><code>a::b</code> 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。</p><p><code>::b</code> 这种形式表示 <strong>其命名空间是全局命名空间</strong>。</p></blockquote><hr><h3 id="全局常量作为外部变量"><a href="#全局常量作为外部变量" class="headerlink" title="全局常量作为外部变量"></a>全局常量作为外部变量</h3><p>当作为内部变量时，可能会出现以下问题：</p><p>虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:</p><blockquote><p><strong>头文件保护符(header guards)</strong>只能确保在单个文件中包含的头文件只包含一次；</p></blockquote><ul><li>当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。</li><li>如果常量的size很大，并且不能进行优化。这将花费很多内存。</li></ul><hr><p>一个解决上面的办法就是，将这些常量设为<strong>“外部变量(external variables)”</strong>。</p><blockquote><p>因此，我们可以将变量只初始化一次就可以在整个程序中使用。</p></blockquote><p><code>constants.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//actual global variables</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>constants.cpp</code>文件中定义这些常量，来确保它们只被定义一次；</p></blockquote><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> avogadro;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> my_gravity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>需要在头文件<code>constants.h</code>中对这些常量进行 提前声明</p></blockquote><p><code>main.cpp</code></p><blockquote><p>使用的方法不变</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">// include all the forward declarations</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用<code>g_</code>前缀</p></blockquote><p>现在，这些符号常量只用在<code>constants.cpp</code>中实例化一次(而不是每次constants.h被<code>#include</code>中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。</p><p>然而，这种方法也有几个缺点。</p><ul><li><strong>首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量</strong>，<strong>而不是在其他地方使用它们</strong>。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。</li><li>其次，编译器可能无法对它们进行尽可能多的优化。</li></ul><hr><h3 id="全局常量作为内联变量"><a href="#全局常量作为内联变量" class="headerlink" title="全局常量作为内联变量"></a>全局常量作为内联变量</h3><p>在C++17中，有一个新概念叫做：<strong><em>inline variable</em>(内联变量)</strong></p><blockquote><p><strong>inline</strong>意为：允许多个定义。</p></blockquote><p>所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 <strong>单定义规则</strong>)</p><blockquote><p><strong>内联全局变量</strong> 默认是 <strong>外部连接</strong></p></blockquote><hr><p>内联变量有两个重要的限制，必须遵守：</p><ul><li>内联变量的所有定义必须相同（否则，将产生未定义的行为）；</li><li>内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。</li></ul><blockquote><p>编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作<code>a.cpp</code>文件中只有一个定义。</p><p>这些变量在它们被包含的文件中，依然保持这 constexpr 的性质</p></blockquote><p>这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123; <span class="number">3.14159</span> &#125;; <span class="comment">// note: now inline constexpr</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在尽可能多的代码文件中包含<code>constants.h</code>，但是这些变量只会被实例化一次，并在所有代码文件中共享。</p></blockquote><hr><p>如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 <strong>内联变量</strong></p><hr><h2 id="6-9-非常量的全局变量evil"><a href="#6-9-非常量的全局变量evil" class="headerlink" title="6.9 非常量的全局变量evil"></a>6.9 非常量的全局变量evil</h2><p>最大的问题就是：<strong>当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_mode; <span class="comment">//声明全局变量(将默认被初始化为0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode = <span class="number">2</span>; <span class="comment">//这里修改全局变量g_mode为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode =<span class="number">1</span>; <span class="comment">//note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量!</span></span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_mode == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"no threat detected.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lanunching nuclear missiles...\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>局部变量要安全得多，因为其他函数不能直接影响它们。</strong></p></blockquote><hr><h3 id="保护你的全局变量"><a href="#保护你的全局变量" class="headerlink" title="保护你的全局变量"></a>保护你的全局变量</h3><p>如果你非要使用全局变量：</p><ul><li><strong>那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。</strong></li><li>最好也将其<strong>放在你自己创建的命名空间，从而避免一些命名冲突。</strong></li></ul><hr><h2 id="6-10-静态局部变量"><a href="#6-10-静态局部变量" class="headerlink" title="6.10 静态局部变量"></a>6.10 静态局部变量</h2><p>术语<code>static</code>是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。</p><p>在之前的课程中，我们讨论了<strong>全局变量具有静态持续时间</strong>，<strong>这意味着它们在程序启动时创建，在程序结束时销毁。</strong></p><p>我们还讨论了<strong><code>static</code>关键字如何提供全局标识符内部链接</strong>，<strong>这意味着标识符只能在定义它的文件中使用。</strong></p><hr><p>我们将探讨<strong>应用于局部变量时静态关键字的用法</strong>。</p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>, 您了解到，默认情况下 局部变量具有 <em>自动持续时间</em>，<strong>这意味着它们是在定义时创建的，并在块退出时销毁。</strong></p><blockquote><p>但<strong>关键字<code>static</code></strong>，可以将<strong><em>自动持续时间(attomatic duration)</em></strong>转变成 <strong><em>静态持续时间(static duration)</em></strong> 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。</p><blockquote><p>这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。</p></blockquote></blockquote><p>例如：</p><p><em>默认是 automatic duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">1</span> &#125;; <span class="comment">// 默认是 automatic duration</span></span><br><span class="line">    ++value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// value is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>每次</strong>调用函数<code>incrementAndPrint()</code>时，都将穿件一个叫value的变量，它被初始化为1</p></blockquote><hr><p>现在使用<code>static</code>关键字，将默认的 <em>atuomatic duration</em> 转变为 <em>static duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// 由于使用关键字 static,所以现在是 static duration。  所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化）</span></span><br><span class="line">    ++s_value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// s_value is not destroyed here, but becomes inaccessible because it goes out of scope</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果****/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个程序中，<strong>因为s_value被声明为静态的</strong>，<u><strong>所以s_value只创建一次(在程序启动时)(并且初始化为零)。</strong></u>然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。</p></blockquote><blockquote><p>就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。</p></blockquote><hr><p><strong>静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)</strong>，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。</p><hr><h3 id="全局、局部变量使用static"><a href="#全局、局部变量使用static" class="headerlink" title="全局、局部变量使用static"></a>全局、局部变量使用<code>static</code></h3><p>全局变量使用关键字<code>static</code>：这会使得全局变量变为 <strong><em>internal linkage(内部连接)</em></strong>，即，使得该变量不能再其他文件中使用。</p><p>局部变量使用关键字<code>statci</code>：这使得局部变量变为 <strong><em>static duration(静态持续时间)</em></strong>,即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。</p><hr><h2 id="6-11-总结scope-duration-linkage"><a href="#6-11-总结scope-duration-linkage" class="headerlink" title="6.11 总结scope/duration/linkage"></a>6.11 总结scope/duration/linkage</h2><h3 id="总结scope"><a href="#总结scope" class="headerlink" title="总结scope"></a>总结scope</h3><p>标识符的范围决定了它能够被访问的区间：</p><ul><li>具有 <strong>block scope(块范围)</strong> / <strong>local scope(局部范围)</strong> 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：<ul><li>局部变量；</li><li>函数的形参；</li><li>在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;</li></ul></li><li>具有 <strong>global scope(全局范围)</strong> / <strong>file scope(文件范围)</strong>的变量 可以再文件中的任何地方被访问，这些有：<ul><li>全局变量；</li><li>函数；</li><li>在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))</li></ul></li></ul><hr><h3 id="总结duration"><a href="#总结duration" class="headerlink" title="总结duration"></a>总结duration</h3><p>变量的持续时间决定了它们何时被创建与销毁：</p><ul><li>具有 <strong>automatic duration(自动持续时间)</strong>的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：<ul><li>局部变量；</li><li>函数的形参；</li></ul></li><li>具有 <strong>static duration(静态持续时间)</strong>的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：<ul><li>全局变量；</li><li>静态局部变量；</li></ul></li><li>具有 <strong>dynamic duration(动态持续时间)</strong>的变量 由程序员请求创建和销毁。这些有：<ul><li>动态分配的变量；</li></ul></li></ul><hr><h3 id="总结linkage"><a href="#总结linkage" class="headerlink" title="总结linkage"></a>总结linkage</h3><p>标识符的 <strong><em>linkage</em>(连接)</strong> 决定了 一个标识符的多个实例是否引用同一个标识符。</p><ul><li>标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：<ul><li>局部变量；</li><li>在块中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>intrnal linkage</em>(内部连接)</strong> 的标识符 只能在它所声明的文件中 被访问。这些有：<ul><li>静态全局变量(static global variables) [初始化 或 未初始化 ]；</li><li>静态函数（static functions）;</li><li>在未命名的命名空间中声明的函数；</li><li>在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>external linkage(外部连接)</em></strong> 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:<ul><li>函数；</li><li>非常量的全局变量(初始化 或 未初始化)；</li><li>外部常量全局变量；</li><li>内联常量全局变量；</li><li>在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；</li></ul></li></ul><hr><blockquote><p>NOTE:</p><p>默认情况下， 函数是 外部连接；它可通过使用关键字<code>static</code>变成 内部连接。</p></blockquote><hr><h3 id="变量的-scope-duratio-linkage"><a href="#变量的-scope-duratio-linkage" class="headerlink" title="变量的 scope/duratio /linkage"></a>变量的 scope/duratio /linkage</h3><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Scope</th><th align="left">Duration</th><th align="left">Linkage</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Local variable</td><td align="left">int x;</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Static local variable</td><td align="left">static int s_x;</td><td align="left">Block</td><td align="left">Static</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Dynamic variable</td><td align="left">int *x { new int };</td><td align="left">Block</td><td align="left">Dynamic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Function parameter</td><td align="left">void foo(int x)</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">External non-constant global variable</td><td align="left">int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal non-constant global variable</td><td align="left">static int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal constant global variable</td><td align="left">constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">External constant global variable</td><td align="left">extern constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">Inline constant global variable</td><td align="left">inline constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr></tbody></table><hr><h3 id="总结提前声明"><a href="#总结提前声明" class="headerlink" title="总结提前声明"></a>总结提前声明</h3><p>你可以在其他文件中对一个 函数/变量 进行提前声明：</p><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Function forward declaration</td><td align="left">void foo(int x);</td><td align="left">Prototype only, no function body</td></tr><tr><td align="left">Non-constant global variable forward declaration</td><td align="left">extern int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Const global variable forward declaration</td><td align="left">extern const int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Constexpr global variable forward declaration</td><td align="left">extern constexpr int g_x;</td><td align="left"><u>Not allowed, constexpr cannot be forward declared</u></td></tr></tbody></table><hr><h3 id="什么是存储类说明符"><a href="#什么是存储类说明符" class="headerlink" title="什么是存储类说明符?"></a>什么是存储类说明符?</h3><p>当关键字<code>static</code> 、<code>extern</code>用作标识符声明的一部分时,它们就被称为：<strong>storage class specifier（存储类说明符）</strong>。它们设置标识符的存储的 <em>duration</em> 和 <em>linkage</em></p><p>C++支持4中存储类说明符：</p><table><thead><tr><th align="left">Specifier</th><th align="left">Meaning</th><th align="left">Note</th></tr></thead><tbody><tr><td align="left">extern</td><td align="left">static (or thread_local) storage duration and external linkage</td><td align="left"></td></tr><tr><td align="left">static</td><td align="left">static (or thread_local) storage duration and internal linkage</td><td align="left"></td></tr><tr><td align="left">thread_local</td><td align="left">thread storage duration</td><td align="left">Introduced in C++11</td></tr><tr><td align="left">mutable</td><td align="left">object allowed to be modified even if containing class is const</td><td align="left"></td></tr><tr><td align="left">auto</td><td align="left">automatic storage duration</td><td align="left">Deprecated in C++11</td></tr><tr><td align="left">register</td><td align="left">automatic storage duration and hint to the compiler to place in a register</td><td align="left">Deprecated in C++17</td></tr></tbody></table><blockquote><p>术语 <em>storage class specifier</em> 通常只在正式文档中使用。</p></blockquote><hr><h2 id="6-12-using-语句"><a href="#6-12-using-语句" class="headerlink" title="6.12 using 语句"></a>6.12 using 语句</h2><p>如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：<strong><em>using statements</em></strong></p><h3 id="using的声明"><a href="#using的声明" class="headerlink" title="using的声明"></a>using的声明</h3><p>一种简化的方法是使用using声明语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// this using declaration tells the compiler that cout should resolve to std::cout</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// so no std:: prefix is needed here!</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// the using declaration expires here</span></span><br></pre></td></tr></table></figure><blockquote><p>using 的声明：<code>using std::cout</code>告诉编译器我们将要使用 命名空间std 中的<code>cout</code>。所以当编译器看到cout时，它会假设我们指的是std::cout。</p><p>如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。</p></blockquote><p>上面的例子，看起来似乎没有简化多少。但如果我们要多次使用<code>cout</code>时，使用 <code>using statements</code>就可以简化很多。</p><blockquote><p>注意，如果你多次使用<code>std::cout</code>和<code>std::cin</code>的话，你需要对他们两个分别使用<code>using statements</code></p></blockquote><hr><h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>另一种方法就是使用：<code>using directive</code>语句。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span>; <span class="comment">// 所以，前缀 std:: 就可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个using 指令 ：<code>using namespace std</code>告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。</p><p>结果就是，当编译器遇到<code>cout</code>(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。</p><hr><p>如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它<strong>标记为错误</strong>(而不是选择其中之一)。</p></blockquote><p>下面来看一下 using 指令 造成的歧义：</p><ul><li><p>eg1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> a</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> b</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> a;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> b;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子中，编译器无法在mian函数中决定使用<code>a::x</code>还是<code>b::x</code>。然后就会出现“不明确的符号”错误。</p><p>要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。</p></blockquote></li><li><p>eg2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eg2中，编译器无法判断我们使用的<code>cout</code>是引用的 <code>std::cout</code>还是 cout函数。并出现“不明确的符号”错误。</p><hr><p>解决方法：</p><ol><li><p>使用<code>using declaration</code> 来替代 <code>using directive</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//告诉编译器， cout 指的是 std::cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//所以cout表示的是 std::cout</span></span><br></pre></td></tr></table></figure></li><li><p>显示的使用前缀：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//告诉编译器使用的是std::cout</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><hr><h3 id="取消or替换-using语句"><a href="#取消or替换-using语句" class="headerlink" title="取消or替换 using语句"></a>取消or替换 using语句</h3><p>一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Foo;</span><br><span class="line">    <span class="comment">//此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;”</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//using namespace Foo ends here</span></span><br></pre></td></tr></table></figure><p>对应它的最好办法就是，显示的限制 using语句 的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> Foo; <span class="comment">//在这里调用Foo::中的东西</span></span><br><span class="line">    &#125; <span class="comment">//using namespace Foo 过期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>	<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<strong>可以显式地使用范围解析操作符(::)来避免所有这些麻烦。</strong></p><hr><h2 id="6-13-typedef与类型别名"><a href="#6-13-typedef与类型别名" class="headerlink" title="6.13 typedef与类型别名"></a>6.13 typedef与类型别名</h2><center>**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**</center><p><code>typedef</code>允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。</p><blockquote><p>Typedef的字面意思是“<strong>类型定义”</strong></p></blockquote><p>我们可以使用关键字<code>typedef</code>，来进行 类型定义：</p><blockquote><p><code>typedef a b</code> ：其中<code>a</code>表示类型的名字，<code>b</code>表示类型被替换成的别名.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个语句是等价的:</span></span><br><span class="line"><span class="keyword">double</span> howFar;</span><br><span class="line"><span class="keyword">distance_t</span> howFar;</span><br></pre></td></tr></table></figure><blockquote><p>按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。</p></blockquote><hr><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 <strong>type alias(类型别名)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型的 别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">double</span>; <span class="comment">//定义distance_t 作为 double类型的 别名【推荐】</span></span><br></pre></td></tr></table></figure><blockquote><p>上面两个语句在功能上等价。</p><p>【NOTE】虽然使用了关键字<code>using</code>（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。</p></blockquote><hr><h4 id="为易读性使用类型别名"><a href="#为易读性使用类型别名" class="headerlink" title="为易读性使用类型别名"></a>为易读性使用类型别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> testScore_t = <span class="keyword">int</span>;</span><br><span class="line"><span class="function">testScore_t <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="使用类型别名编写与平台无关的代码"><a href="#使用类型别名编写与平台无关的代码" class="headerlink" title="使用类型别名编写与平台无关的代码"></a>使用类型别名编写与平台无关的代码</h4><p>比如，在一些平台中，<code>int</code>类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。</p><p>所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INT_2_BYTES</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = short;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果，在一个机器中，整数是2个字节。那么<code>INT_2_BYTES</code>将被定义。此时，就使用的是上部定义的这几个。</p><p>如果，在一个机器中，整数是4个字节。那么<code>INT_2_BYTES</code>将不被定义。此时，就使用的是下部定义的这几个。</p><hr><p>这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的</p><p><code>int_8</code>将处理 1字节的整数；</p><p><code>int16_t</code>将处理 2字节的整数；</p><p><code>int32_t</code>将处理 4字节的整数。</p></blockquote><hr><h2 id="6-14-关键字auto"><a href="#6-14-关键字auto" class="headerlink" title="6.14 关键字auto"></a>6.14 关键字<code>auto</code></h2><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d &#123;<span class="number">5.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果C++早就知道<code>5.0</code>是double类型的数字，那为什么我们还要显示的指定<code>d</code>是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?</p><h3 id="初始化变量的类型推断"><a href="#初始化变量的类型推断" class="headerlink" title="初始化变量的类型推断"></a>初始化变量的类型推断</h3><p>当初始化一个变量，关键字<code>auto</code>可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：<strong><em>type inference</em>(类型推断)</strong>, 英文中也可以叫作：<strong><em>type deduction</em></strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">5.0</span>&#125;; <span class="comment">//因为5.0是一个double类型的数字，所以它的类型将被推断为double</span></span><br><span class="line"><span class="keyword">auto</span> i &#123;<span class="number">1</span>+<span class="number">2</span>&#125;; <span class="comment">//因为1+2的结果是int类型，所以，i 将被推断为int类型</span></span><br></pre></td></tr></table></figure><p>也可以用在函数返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum&#123;add(<span class="number">5</span>,<span class="number">6</span>)&#125;; <span class="comment">//add() 返回一个int, 所以sum的类型将被推断为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="在C-14中函数的类型推断"><a href="#在C-14中函数的类型推断" class="headerlink" title="在C++14中函数的类型推断"></a>在C++14中函数的类型推断</h3><p>在C++14中，关键字<code>auto</code>被扩展到可以从函数体中的返回语句推断出函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>x+y</code>的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用<code>auto</code>返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。</p></blockquote><p>但是不推荐对函数的返回类型使用关键字<code>auto</code>。</p><blockquote><p>因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。</p></blockquote><hr><h3 id="后置返回类型语法"><a href="#后置返回类型语法" class="headerlink" title="后置返回类型语法"></a>后置返回类型语法</h3><p>关键字<code>auto</code>也可以被用来<strong>后置返回类型(trailing return syntax)</strong>。即，在函数原型之后指定返回的类型。</p><blockquote><p>这是C++11新增的<strong>一种函数声明</strong>的方法。</p></blockquote><p>下面的两个对函数声明的语句是等价的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。</span><br></pre></td></tr></table></figure><hr><p>那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto add(int x, int y) -&gt; int;</span><br><span class="line">auto divide(double x, double y) -&gt; double;</span><br><span class="line">auto printSomething() -&gt; void;</span><br><span class="line">auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;</span><br></pre></td></tr></table></figure><hr><h3 id="函数形参的类型推断"><a href="#函数形参的类型推断" class="headerlink" title="函数形参的类型推断"></a>函数形参的类型推断</h3><blockquote><p><strong>在C++20时引入的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">//only valid in C++20</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>); 	   <span class="comment">//int</span></span><br><span class="line">    add(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">//double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在C++20之前</strong>，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。</p><blockquote><p>在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用<code>function templates</code>，而不是现在用的<code>type inference</code></p></blockquote><hr><h3 id="6-15-强制类型转换-隐式"><a href="#6-15-强制类型转换-隐式" class="headerlink" title="6.15 强制类型转换(隐式)"></a>6.15 强制类型转换(隐式)</h3><blockquote><p>类型转换有两种形式：</p><ul><li><strong>implicit type conversion</strong>（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型</li><li><strong>explicit type conversion</strong>（显示类型转换）：开发人员使用转换操作符来指导转换。</li></ul></blockquote><p>将值从一种数据类型转换为另一种数据类型的过程称为<strong><em>type conversion</em>(类型转换)</strong>。类型转换可以在许多不同的情况下发生:</p><ul><li><p>当用不同数据类型的值 分配 或 初始 化一个变量时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">3</span>&#125;;  <span class="comment">// initialize double variable with integer value 3</span></span><br><span class="line">d = <span class="number">6</span>;  	  <span class="comment">// assign double variable the integer value 6</span></span><br></pre></td></tr></table></figure></li><li><p>当传递一个值给一个函数时，但函数参数是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">doSomething(<span class="number">3</span>); <span class="comment">// pass integer value 3 to a function expecting a long parameter</span></span><br></pre></td></tr></table></figure></li><li><p>当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.0</span>; <span class="comment">// Return double value 3.0 back to caller through float return type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用不同类型的操作数的 二元操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> division&#123; <span class="number">4.0</span> / <span class="number">3</span> &#125;; <span class="comment">// division with a double and an integer</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><strong>隐式类型转换</strong>(也称为<strong>自动类型转换</strong>或<strong>强制转换</strong>)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。</p><blockquote><p>隐式类型转换有两种基本类型：<strong>提升</strong>和<strong>转换</strong>。</p></blockquote><ul><li><p><strong><em>Numeric promotion</em>数值提升</strong></p><p>每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为<strong>数值提升</strong>(或<strong>加宽</strong>，尽管这个术语通常用于整数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//an int can be widened into a long, or a float promoted into a double:</span></span><br><span class="line"><span class="keyword">long</span> l&#123; <span class="number">64</span> &#125;; <span class="comment">// widen the integer 64 into a long</span></span><br><span class="line"><span class="keyword">double</span> d&#123; <span class="number">0.12f</span> &#125;; <span class="comment">// promote the float 0.12 into a double</span></span><br></pre></td></tr></table></figure><p>虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:</p><ul><li><strong>Integral promotion(整型提升)</strong>：可以将[ <code>bool</code> , <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, <code>unsigned short</code>, and <code>signed short</code> ]这些类型转换为 <code>int</code>或者是<code>unsigned int</code></li><li><strong>Floating point promotion(浮点型提升)</strong>：可以将<code>float</code>类型转换为<code>double</code></li></ul><p>整型提升 和 浮点型提升 通常是将 较小的数据类型转换为<code>int</code>/<code>unsigned int</code>或<code>double</code>。</p><hr></li><li><p><strong>Numeric conversions(数值转换)</strong></p><p>当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123; <span class="number">3</span> &#125;; <span class="comment">// convert integer 3 to a double (between different types)</span></span><br><span class="line">short s&#123; <span class="number">2</span> &#125;; <span class="comment">// convert integer 2 to a short (from larger to smaller type within same type family)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>数值提升</strong>是安全的；但是<strong>数值转换</strong>可能会丢失数据。</p><blockquote><p>因此，导致执行隐式转换的代码通常会导致编译器发出警告。</p></blockquote></blockquote><p>eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">30000</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> c = i; <span class="comment">// chars have range -128 to 127</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48</p></blockquote><p>但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    short s = i; <span class="comment">// convert from int to short</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">0.1234</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********结果**************/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0.1234</span></span><br></pre></td></tr></table></figure><p>对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.123456789</span>; <span class="comment">// double value 0.123456789 has 9 significant digits, but float can only support about 7</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// std::setprecision defined in 头文件“iomanip”中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************结果************/</span></span><br><span class="line"><span class="number">0.123456791</span></span><br></pre></td></tr></table></figure><p>只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************结果**************/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***在本例中，丢失了分数值(.5)，结果如下:****/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>计算算术表达式</strong></p><p>当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的<strong>操作数必须是相同的类型</strong>。为了确保这一点，编译器使用以下规则:</p><ul><li><p>如果一个操作数是一个比<code>int</code>更窄的整数，它将经历整数提升(如上所述)到<code>int</code>或<code>usigned int</code>。</p></li><li><p>如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。</p><blockquote><p>操作数的优先级如下:</p><ul><li>long double (highest)</li><li>double</li><li>float</li><li>unsigned long long</li><li>long long</li><li>unsigned long</li><li>long</li><li>unsigned int</li><li>int (lowest)</li></ul></blockquote></li></ul><p>我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。</p><p>eg1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    short b&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a + b).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of a + b</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。</p></blockquote><p>eg2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    short s&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(d + s).name() &lt;&lt; <span class="string">' '</span> &lt;&lt; d + s &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of d + s</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****结果*************/</span></span><br><span class="line"><span class="keyword">double</span> <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>short</code>将被 <em>数值提升</em> 为<code>int</code>。但是，<code>int</code>与<code>double</code>还是不匹配。又因为<code>double</code>在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.</p></li></ul><hr><h2 id="强制类型转换-显式-amp-static-cast"><a href="#强制类型转换-显式-amp-static-cast" class="headerlink" title="强制类型转换(显式) &amp; static_cast"></a>强制类型转换(显式) &amp; <code>static_cast</code></h2><p>显式的类型转换是使用 <strong>type casting operator(类型转换操作符)</strong>。（通常是程序员来做的一个显式的的类型转换）</p><p>在C++中，类型转换大致分为5种： <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. 后四个有时被称为<strong>命名类型转换(named casts)</strong>。</p><p>在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。</p><blockquote><p>通常应该避免使用<code>Const casts</code>和<code>reinterpret casts</code>，因为它们只在极少数情况下有用，如果使用不当可能会有害。</p></blockquote><hr><h3 id="C-style-casts"><a href="#C-style-casts" class="headerlink" title="C-style casts"></a>C-style casts</h3><p>在标准的C语言中，类型转换是通过 <strong>操作符<code>()</code></strong>来完成的。括号内是将要转换的目标类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 &#123; <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i2 &#123; <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">float</span> f &#123; (<span class="keyword">float</span>)i1 / i2 &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将<code>i1</code>转换为浮点值。</p><p>因为运算符<code>/</code>的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!</p></blockquote><hr><p><strong>使用强制类型转换来清除隐式类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">48</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// explicit conversion from int to char, so that a char is assigned to variable ch</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br></pre></td></tr></table></figure><blockquote><p>当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个<code>static_cast</code>的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。</p></blockquote><p>下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = i / <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>告诉编译器，我们明确的意思是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i / <span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="6-17-未命名-内联-命名空间"><a href="#6-17-未命名-内联-命名空间" class="headerlink" title="6.17 未命名/内联 命名空间"></a>6.17 未命名/内联 命名空间</h2><h3 id="未命名-匿名-命名空间"><a href="#未命名-匿名-命名空间" class="headerlink" title="未命名(匿名) 命名空间"></a>未命名(匿名) 命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管<code>doSomething</code>函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是<code>global namespace</code>)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。</p></blockquote><p>这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有<strong>内部链接</strong>，<u>这意味着未命名命名空间的内容就不能在其他文件中看到</u>。</p><hr><p><strong>对于函数</strong>，<u>这实际上等同于将未命名的命名空间中的所有函数定义为<strong>静态函数</strong></u>。下面的程序与上面的程序实际上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><code>unnamed namespace</code></strong>通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用<code>unnamed namespace</code>要比单独将所有声明标记为<code>static</code>更容易。</p><hr><h3 id="内联-命名空间"><a href="#内联-命名空间" class="headerlink" title="内联 命名空间"></a>内联 命名空间</h3><blockquote><p><strong>Inline namespaces</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?</p><ul><li><p>一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。</p></li><li><p>【推荐】另一种方法是使用<strong>内联命名空间</strong>。<u>内联命名空间是通常用于版本化内容的名称空间</u>。与未命名的命名空间非常相似，<u>在内联命名空间中声明的任何内容都被认为是父名称空间的一部分</u>。<u>然而，内联命名空间并不是 内部链接。</u></p><blockquote><p>使用关键字<code>inline</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 <span class="comment">// declare an inline namespace named v1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> v2 <span class="comment">// declare a normal namespace named v2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// calls the v1 version of doSomething()</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// calls the v2 version of doSomething()</span></span><br><span class="line"> </span><br><span class="line">    doSomething(); <span class="comment">// calls the inline version of doSomething() (which is v1)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，当有 <strong>内联函数</strong>存在时，<u>如果不加前缀，<strong>则默认调用的是 内联函数版本</strong></u></p></blockquote><p>在上面的例子中，调用<code>doSomething</code>将得到<code>doSomething</code>的v1(内联版本)。希望使用新版本的调用者可以<strong>显式</strong>地调用<code>v2::dosomething()</code>。</p><blockquote><p>这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。</p></blockquote><hr></li></ul><h2 id="6-x-Chapter-6-summary-and-quiz"><a href="#6-x-Chapter-6-summary-and-quiz" class="headerlink" title="6.x Chapter 6 summary and quiz"></a>6.x Chapter 6 summary and quiz</h2><p><a href="https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/</a></p><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://www.longlongqin.top/archives/2faa8a4b.html">https://www.longlongqin.top/archives/2faa8a4b.html</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/AliPayOR.jpg" height="64px"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/WeChatPayOR.png" height="64px"></fancybox></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-04-13T17:43:38+08:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2020年4月13日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/C-C/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i><p>C/C++</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.longlongqin.top/archives/2faa8a4b.html&title=C&C++/LearnCpp-chapter6 - 龙龙‘S BLOG&summary=LearnCpp chapter6https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.longlongqin.top/archives/2faa8a4b.html&title=C&C++/LearnCpp-chapter6 - 龙龙‘S BLOG&summary=LearnCpp chapter6https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://www.longlongqin.top/archives/2faa8a4b.html&title=C&C++/LearnCpp-chapter6 - 龙龙‘S BLOG&summary=LearnCpp chapter6https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/archives/7a585be8.html"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>鸟哥私房菜linux</p><p class="content">鸟哥私房菜http://linux.vbird.org/linux_basic/5️⃣Linux的档案权限与目录配置元件内容叠代物件rwx档案详细资料data文件资料夹读到文件内容修改文件内容执...</p></a><a class="next" href="/archives/9f0a1d82.html"><p class="title">转载他人的方法<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">WSL 使用指南：https://zhuanlan.zhihu.com/p/36482795</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script>window.subData={title:"C&C++/LearnCpp-chapter6",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-用户自定义namespace"><span class="toc-text">6.2 用户自定义namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-局部变量"><span class="toc-text">6.3 局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量的块范围"><span class="toc-text">局部变量的块范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同一范围内的变量名不相同"><span class="toc-text">同一范围内的变量名不相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量的自动存储期"><span class="toc-text">局部变量的自动存储期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套快中的局部变量"><span class="toc-text">嵌套快中的局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量的无连接"><span class="toc-text">局部变量的无连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量定义的范围"><span class="toc-text">变量定义的范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-全局变量"><span class="toc-text">6.4 全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量的声明"><span class="toc-text">全局变量的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量的file-scope-amp-静态持续时间"><span class="toc-text">全局变量的file scope&amp;静态持续时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量局部变量"><span class="toc-text">常量局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-变量被隐藏"><span class="toc-text">6.5 变量被隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量被隐藏"><span class="toc-text">局部变量被隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量被隐藏"><span class="toc-text">全局变量被隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免变量被隐藏"><span class="toc-text">避免变量被隐藏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-内部连接"><span class="toc-text">6.6 内部连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量内部连接"><span class="toc-text">全局变量内部连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个定义规则和内部连接"><span class="toc-text">一个定义规则和内部连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数内部连接"><span class="toc-text">函数内部连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-外部连接"><span class="toc-text">6.7 外部连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数默认是外部链接"><span class="toc-text">函数默认是外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量外部连接"><span class="toc-text">全局变量外部连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern提前声明变量"><span class="toc-text">extern提前声明变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数提前声明不用extern"><span class="toc-text">函数提前声明不用extern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file范围VS-global范围"><span class="toc-text">file范围VS.global范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量初始化顺序问题"><span class="toc-text">全局变量初始化顺序问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-全局常量-amp-内联变量"><span class="toc-text">6.8 全局常量&amp;内联变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局常量作为内部变量"><span class="toc-text">全局常量作为内部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局常量作为外部变量"><span class="toc-text">全局常量作为外部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局常量作为内联变量"><span class="toc-text">全局常量作为内联变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-非常量的全局变量evil"><span class="toc-text">6.9 非常量的全局变量evil</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#保护你的全局变量"><span class="toc-text">保护你的全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-静态局部变量"><span class="toc-text">6.10 静态局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局、局部变量使用static"><span class="toc-text">全局、局部变量使用static</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-总结scope-duration-linkage"><span class="toc-text">6.11 总结scope&#x2F;duration&#x2F;linkage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结scope"><span class="toc-text">总结scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结duration"><span class="toc-text">总结duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结linkage"><span class="toc-text">总结linkage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量的-scope-duratio-linkage"><span class="toc-text">变量的 scope&#x2F;duratio &#x2F;linkage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结提前声明"><span class="toc-text">总结提前声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是存储类说明符"><span class="toc-text">什么是存储类说明符?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-using-语句"><span class="toc-text">6.12 using 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using的声明"><span class="toc-text">using的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-指令"><span class="toc-text">using 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取消or替换-using语句"><span class="toc-text">取消or替换 using语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-13-typedef与类型别名"><span class="toc-text">6.13 typedef与类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型别名"><span class="toc-text">类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为易读性使用类型别名"><span class="toc-text">为易读性使用类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用类型别名编写与平台无关的代码"><span class="toc-text">使用类型别名编写与平台无关的代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-14-关键字auto"><span class="toc-text">6.14 关键字auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化变量的类型推断"><span class="toc-text">初始化变量的类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在C-14中函数的类型推断"><span class="toc-text">在C++14中函数的类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后置返回类型语法"><span class="toc-text">后置返回类型语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数形参的类型推断"><span class="toc-text">函数形参的类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-15-强制类型转换-隐式"><span class="toc-text">6.15 强制类型转换(隐式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式类型转换"><span class="toc-text">隐式类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#强制类型转换-显式-amp-static-cast"><span class="toc-text">强制类型转换(显式) &amp; static_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-style-casts"><span class="toc-text">C-style casts</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-17-未命名-内联-命名空间"><span class="toc-text">6.17 未命名&#x2F;内联 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#未命名-匿名-命名空间"><span class="toc-text">未命名(匿名) 命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内联-命名空间"><span class="toc-text">内联 命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-x-Chapter-6-summary-and-quiz"><span class="toc-text">6.x Chapter 6 summary and quiz</span></a></li></ol></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2020 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：132.4k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.0/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"TYFUId8Xuddv6nUYuVUHJbac-gzGzoHsz",appKey:"bCYkC8WKY7n8VjI7K2g8MMJ3",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>